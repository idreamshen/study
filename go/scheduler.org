* Go 调度器
以下内容来自 ChatGPT4

** 基础概念
Go 语言的调度器是其运行时系统的一部分，负责在操作系统线程上调度 goroutine 的执行。
Go 的调度器采用了 M:N 的模型，这意味着 M 个操作系统线程可以运行 N 个 goroutine。
这种设计方式使得 Go 程序可以轻松地启动成千上万的 goroutine，而不需要担心操作系统线程的开销。

以下是 Go 调度器的几个核心概念：
- Goroutine (G)：这是用户级线程或轻量级线程。它不是直接由操作系统管理，而是由 Go 运行时调度并在操作系统线程上执行。
- Operating System Thread (M)：这是实际的操作系统线程。Go 的调度器会在这些线程上调度 goroutines 的执行。
- Processor (P)：这是 Go 调度器的一个内部概念，表示一个可以执行 Go 代码的资源。每个 P 都绑定到一个 M 并且在某一时刻只能执行一个 G。

下面是调度器的工作原理的简要概述：

- 当一个 Goroutine 通过 go 关键字启动时，它会被加入到一个 P 的本地队列中。
- 当 M 有一个与其关联的 P 时，它会尝试从 P 的本地队列中取一个 G 来执行。
- 如果 P 的本地队列为空，它可能会从其他 P 的本地队列中偷取 G，或者从全局队列中取一个 G。
- 当 G 被阻塞（例如，等待 I/O 或同步原语），M 可能会被解除与 P 的绑定并执行其他的 G。与此同时，被阻塞的 G 会被移到等待队列中。
- 当阻塞的 G 变得可以再次运行时（例如，I/O 完成），它会被重新加入到一个 P 的本地队列中。

Go 的调度器还具有以下特点：

- 工作窃取：当一个 P 的本地队列为空时，它可以尝试从其他 P 的本地队列中“窃取”工作（Goroutine）。
- 协同调度：Go 的调度器并不依赖于操作系统的线程调度。它使用了自己的逻辑和机制来决定何时以及在哪个 M 上运行 G。
- 网络轮询器：Go 的调度器内置了一个网络轮询器，用于非阻塞地处理 I/O 操作，这允许它在等待 I/O 完成时释放 M 并执行其他 Goroutine。
** 我了解到调度器早期设计时不是 gmp，好像缺少了 p，当时是怎么设计的
确实，Go 的调度器在早期版本中不是现在的 GMP 模型。在初期，Go 采用了一个比较简单的调度模型，其中没有明确的 `P`（Processor）的概念。

早期的设计大致如下：
1. G (Goroutines)：这与现在的概念相同，即表示轻量级的线程，是 Go 代码执行的单位。
2. M (Machine)：代表操作系统的线程。与现在的设计相似，每个 Goroutine 都在某个 M 上运行。
3. 全局队列：所有新创建的 Goroutines 都首先放在一个全局的队列中。
4. 工作窃取：当一个 M（操作系统线程）没有工作时，它会从全局队列中取出 Goroutines 来执行。
   如果全局队列为空，M 可能会尝试从其他忙碌的 M “窃取” Goroutines。

这种设计的问题是，尽管工作窃取策略可以平衡负载，但频繁地访问全局队列会导致争用，从而降低性能。
当 Goroutines 的数量增加时，这个问题变得更为明显。

为了解决这个问题，Go 的调度器进行了一系列的迭代和改进，最终引入了 `P` 的概念。
每个 `P` 都有自己的本地 Goroutine 队列，这大大减少了全局队列的争用，提高了调度的效率。
同时，工作窃取策略也得到了改进，现在是从其他 `P` 的本地队列中窃取，而不是从全局队列。

简而言之，早期的 Go 调度器没有 `P` 的概念，并且主要依赖于全局队列和工作窃取策略来进行调度。
随着时间的推移，为了提高效率和性能，调度器进行了迭代，并引入了现在的 GMP 模型。
