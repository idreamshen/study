* 1. Two Sum
Given an array of integers, return indices of the two numbers such that they add up to a specific target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

Example:

Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].

#+begin_src java :classname TwoSum :cmdline "-cp ."
  import java.util.HashMap;
  import java.util.Map;

  public class TwoSum {
      public static void main(String[] args) {
          m1(new int[]{2, 7, 11, 15}, 9);
          m2(new int[]{2, 7, 11, 15}, 9);
          m1(new int[]{9, 1, 2, 7}, 9);
          m2(new int[]{9, 1, 2, 7}, 9);
          m1(new int[]{9, 1, 2, 7}, 16);
          m2(new int[]{9, 1, 2, 7}, 16);
      }

      public static void m1(int[] nums, int sum) {
          int i1 = -1;
          int i2 = -1;

          main:
          for (int i = 0; i < nums.length; i++) {
              i1 = -1;
              i2 = -1;
              int left = nums[i];
              if (left > sum) {
                  continue;
              }

              int targetRight = sum - left;

              if (i == nums.length - 1) {
                  break;
              }

              for (int j = i + 1; j < nums.length; j++) {
                  int right = nums[j];
                  if (right == targetRight) {
                      i1 = i;
                      i2 = j;
                      break main;
                  }
              }
          }

          if (i1 != -1 && i2 != -1) {
              System.out.println(i1 + "," + i2);
          } else {
              System.out.println("not found");
          }
      }

      public static void m2(int[] nums, int sum) {
          int i1 = -1;
          int i2 = -1;

          Map<Integer, Integer> m = new HashMap<>();

          for (int i = 0; i < nums.length; i++) {
              int num = nums[i];
              int remain = sum - num;

              if (m.containsKey(remain)) {
                  i1 = i;
                  i2 = m.get(remain);
                  break;
              } else {
                  m.put(num, i);
              }
          }

          if (i1 != -1 && i2 != -1) {
              System.out.println(i1 + "," + i2);
          } else {
              System.out.println("not found");
          }

      }
  }
#+end_src

#+RESULTS:
| 0 | 1 |
| 1 | 0 |
| 2 | 3 |
| 3 | 2 |
| 0 | 3 |
| 3 | 0 |

* 2. Add Two Numbers
You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Example:

Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 0 -> 8
Explanation: 342 + 465 = 807.

#+begin_src java :classname AddTwoNumbers :cmdline "-cp ." :results scalar
    public class AddTwoNumbers {
        static class Node {
            int value;
            Node next;
        }

        public static void main(String[] args) {
            Node node1 = build(new int[] {2, 4, 3});
            Node node2 = build(new int[] {5, 6, 9, 6});

            print(node1);
            print(node2);

            Node resultNode = sum(node1, node2);
            print(resultNode);
        }

        public static Node sum(Node left, Node right) {
            Node head = null;
            Node lastNode = null;

            boolean isLeftEnd = false;
            boolean isRightEnd = false;

            Node tmpLeft = left;
            Node tmpRight = right;
            int incr = 0;

            int i = 0;

            while (true) {
                i++;
                if (tmpLeft == null) {
                    isLeftEnd = true;
                }

                if (tmpRight == null) {
                    isRightEnd = true;
                }

                if ((isLeftEnd && isRightEnd && incr == 0) || i > 1000) {
                    break;
                }

                int tmpLeftValue = 0;
                int tmpRightValue = 0;

                if (tmpLeft != null) {
                    tmpLeftValue = tmpLeft.value;
                }

                if (tmpRight != null) {
                    tmpRightValue = tmpRight.value;
                }

                int tmpCmbValue = incr + tmpLeftValue + tmpRightValue;
                int tmpValue = tmpCmbValue % 10; // 末尾
                incr = tmpCmbValue / 10; // 下一位进多少

                Node tmp = new Node();
                tmp.value = tmpValue;

                if (lastNode == null) {
                    lastNode = tmp;
                    head = tmp;
                } else {
                    lastNode.next = tmp;
                    lastNode = tmp;
                }

                if (tmpLeft != null) {
                    tmpLeft = tmpLeft.next;
                }

                if (tmpRight != null) {
                    tmpRight = tmpRight.next;
                }
            }

            return head;
        }

        public static Node build(int[] nums) {
            Node head = null;
            Node lastNode = null;
            for (int num : nums) {
                Node node = new Node();
                node.value = num;

                if (head == null) {
                    lastNode = node;
                    head = node;
                } else {
                    lastNode.next = node;
                    lastNode = node;
                }
            }

            return head;
        }

        public static void print(Node node) {
            String result = "";
            Node tmp = node;

            int i = 0;

            while(tmp != null && i < 100) {
                result = result + tmp.value;
                tmp = tmp.next;
                i++;
            }

            System.out.println(result);
        }
    }
#+end_src

#+RESULTS:
: 243
: 5696
: 7037
* 3. Longest Substring Without Repeating Characters
Given a string, find the length of the longest substring without repeating characters.

Example 1:

Input: "abcabcbb"
Output: 3 
Explanation: The answer is "abc", with the length of 3. 
Example 2:

Input: "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
Example 3:

Input: "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3. 
             Note that the answer must be a substring, "pwke" is a subsequence and not a substring.
