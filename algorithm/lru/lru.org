* LRU 定义
Least Recently Used 最近最少使用：最久没有访问的内容作为替换对象

* 使用 LinkedHashMap 实现
** LinkedHashMap 之 AccessOrder
我们先看下 LinkedHashMap 中一个比较重要的属性 AccessOrder。这个属性将是后面实现 LRU 的关键点


   #+begin_src java :classname LinkedHashMapTest :cmdline "-cp ." :results output :exports both
     import java.util.LinkedHashMap;
     import java.util.Map;
     import java.util.Map.Entry;

     class LinkedHashMapTest {
         public static void main(String[] args) {
             // 默认以 insert 顺序供访问
             LinkedHashMap<String, String> m1 = new LinkedHashMap();
             m1.put("a", "1");
             m1.put("b", "2");
             m1.put("c", "3");
             System.out.println("以插入顺序提供遍历的 Map 结果如下：");
             print(m1);

             System.out.println("以访问顺序提供遍历的 Map 结果如下：");
             LinkedHashMap<String, String> m2 = new LinkedHashMap(16, 0.75f, true);
             m2.put("a", "1");
             m2.put("b", "2");
             m2.put("c", "3");

             m2.get("a");
             print(m2);
         }

         public static void print(Map<String, String> m) {
             for (Entry<String, String> e : m.entrySet()) {
                 String k = e.getKey();
                 String v = e.getValue();
                 System.out.println("k=" + k + ", v=" + v);
             }
         }
     }
   #+end_src

   #+RESULTS:
   : 以插入顺序提供遍历的 Map 结果如下：
   : k=a, v=1
   : k=b, v=2
   : k=c, v=3
   : 以访问顺序提供遍历的 Map 结果如下：
   : k=b, v=2
   : k=c, v=3
   : k=a, v=1



* 参考资料
- [[https://www.cnblogs.com/yejg1212/archive/2013/04/01/2992921.html][LinkedHashMap的accessOrder的作用]]
- [[https://baike.baidu.com/item/LRU][LRU]]
- [[https://zh.wikipedia.org/wiki/%E5%BF%AB%E5%8F%96%E6%96%87%E4%BB%B6%E7%BD%AE%E6%8F%9B%E6%A9%9F%E5%88%B6][缓存文件置换机制]]
